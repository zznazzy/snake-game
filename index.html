<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Snake</title>
    <style>
      /* --- Minimal, readable styling for a centered canvas game --- */
      body {
        display: flex; align-items: center; justify-content: center;
        min-height: 100vh; font-family: system-ui, sans-serif;
        background: #111; color: #eee;
      }
      .wrap { text-align: center; }
      canvas {
        background: #fff; border: 2px solid #000;
        display: block; margin: 0 auto 12px;
      }
      .hud { display: flex; gap: 16px; justify-content: center; align-items: center; }
      .btn {
        padding: 6px 10px; border: 1px solid #444;
        background: #222; color: #eee; cursor: pointer;
      }
      .btn:hover { filter: brightness(1.15); }
      .btn:focus { outline: 2px solid #4caf50; }
      .controls {
        margin-top: 12px; font-size: 14px; color: #999;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <!-- Fixed-size canvas keeps math simple (30x30 grid @ 10px). -->
      <canvas id="game" width="300" height="300" aria-label="Snake game area"></canvas>

      <!-- Simple HUD for score and controls. -->
      <div class="hud" role="status" aria-live="polite">
        <div>Score: <span id="score">0</span></div>
        <button id="restart" class="btn" aria-label="Restart game">Restart</button>
        <button id="pause" class="btn" aria-label="Pause/Resume game">Pause</button>
      </div>
      
      <div class="controls">
        Use arrow keys to move • R to restart • Space to pause
      </div>
    </div>

    <script>
      /* ============================
         1) Globals and Constants
         ============================ */

      /** @type {HTMLCanvasElement} */
      const canvas = document.getElementById('game');
      /** @type {CanvasRenderingContext2D} */
      const ctx = canvas.getContext('2d');

      /**
       * Size of one grid cell in pixels. All positions snap to this grid.
       * Using a power-of-two-like step (10) simplifies drawing and collisions.
       */
      const CELL = 10;

      // Game state variables (reset by init()).
      /** @type {{x:number,y:number}[]} Snake segments; index 0 is the head. */
      let snake;
      /** @type {number} Horizontal delta per tick (−CELL, 0, or CELL). */
      let dx;
      /** @type {number} Vertical delta per tick (−CELL, 0, or CELL). */
      let dy;
      /** @type {{x:number,y:number}} Current food location snapped to grid. */
      let food;
      /** @type {number} Player score (increments when food is eaten). */
      let score;
      /** @type {number} Milliseconds between ticks; decreases slightly as score rises. */
      let tickMs;
      /** @type {boolean} True while game is active; false after game over. */
      let running;
      /** @type {boolean} True when game is paused. */
      let paused;
      /**
       * @type {boolean}
       * Prevents multiple rapid turns inside a single tick which could cause
       * illegal 180° reversals or inconsistent input.
       */
      let turning;

      /* ============================
         2) Lifecycle
         ============================ */

      /**
       * Initialize or reset the game state to a fresh run.
       * Keeps all setup in one place for reliability and reusability.
       */
      function init() {
        // Start with a short, right-facing snake centered on the grid.
        snake = [{ x: 150, y: 150 }, { x: 140, y: 150 }, { x: 130, y: 150 }];
        dx = CELL; dy = 0;

        score = 0;
        tickMs = 100;     // Start speed; lower is faster
        running = true;
        paused = false;
        turning = false;

        placeFood();      // Ensure food is not placed on the snake
        drawScene();      // Draw once immediately
        updatePauseButton();
        loop();           // Start the tick loop
      }

      /**
       * Main game loop using setTimeout for an adjustable tick rate.
       * requestAnimationFrame is great for rendering, but here we want
       * a fixed-interval step for deterministic movement speed.
       */
      function loop() {
        if (!running) return;
        setTimeout(() => {
          if (!paused) {
            step();
            drawScene();
          }
          loop();
        }, tickMs);
      }

      /* ============================
         3) Drawing
         ============================ */

      /** Clear and frame the canvas for a consistent visual baseline. */
      function clear() {
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
      }

      /** Render each snake segment; head is styled slightly differently. */
      function drawSnake() {
        ctx.strokeStyle = '#033';
        for (let i = 0; i < snake.length; i++) {
          ctx.fillStyle = i === 0 ? '#4caf50' : '#8bc34a';
          const s = snake[i];
          ctx.fillRect(s.x, s.y, CELL, CELL);
          ctx.strokeRect(s.x, s.y, CELL, CELL);
        }
      }

      /** Render the current food cell. */
      function drawFood() {
        ctx.fillStyle = '#e91e63';
        ctx.fillRect(food.x, food.y, CELL, CELL);
      }

      /** Draw pause overlay */
      function drawPauseOverlay() {
        if (!paused) return;
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 22px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
      }

      /** Composite draw: clear, then food, then snake, then overlays, then HUD text. */
      function drawScene() {
        clear();
        drawFood();
        drawSnake();
        drawPauseOverlay();
        document.getElementById('score').textContent = score;
      }

      /* ============================
         4) Game Step and Rules
         ============================ */

      /**
       * Advance one tick:
       * - Compute next head based on current direction
       * - Detect collisions (walls or self)
       * - Grow if eating food; otherwise remove the tail
       * - Occasionally increase speed
       */
      function step() {
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };
        turning = false; // allow one new turn next tick

        if (hitWall(head) || hitSelf(head)) {
          running = false;
          paused = false;
          updatePauseButton();
          gameOver();
          return;
        }

        // Add new head
        snake.unshift(head);

        // Eating?
        if (head.x === food.x && head.y === food.y) {
          score += 1;
          placeFood();
          maybeSpeedUp();
        } else {
          // Move forward without growing
          snake.pop();
        }
      }

      /** @param {{x:number,y:number}} h */
      function hitWall(h) {
        return h.x < 0 || h.x >= canvas.width || h.y < 0 || h.y >= canvas.height;
      }

      /** @param {{x:number,y:number}} h */
      function hitSelf(h) {
        // Simple O(n) check; fine for short snakes and a 300x300 board.
        for (let i = 0; i < snake.length; i++) {
          if (snake[i].x === h.x && snake[i].y === h.y) return true;
        }
        return false;
      }

      /* ============================
         5) Input
         ============================ */

      /**
       * Arrow keys turn the snake. We block turns that would reverse direction
       * on the same axis and we allow only one turn per step for consistency.
       * Updated to use modern 'key' property instead of deprecated keyCode.
       */
      document.addEventListener('keydown', e => {
        // Handle restart and pause for any game state
        if (e.key === 'r' || e.key === 'R') {
          init();
          return;
        }
        
        if (e.key === ' ') {
          e.preventDefault(); // prevent page scroll
          togglePause();
          return;
        }

        if (!running || paused) return;

        if (turning) return; // already turned this tick

        if (e.key === 'ArrowLeft'  && dx === 0) { dx = -CELL; dy = 0; turning = true; }
        if (e.key === 'ArrowRight' && dx === 0) { dx =  CELL; dy = 0; turning = true; }
        if (e.key === 'ArrowUp'    && dy === 0) { dx = 0; dy = -CELL; turning = true; }
        if (e.key === 'ArrowDown'  && dy === 0) { dx = 0; dy =  CELL; turning = true; }
      });

      /* ============================
         6) Food Placement and Difficulty
         ============================ */

      /**
       * Return a random coordinate snapped to the grid on [0, max).
       * Example: if max=300 and CELL=10, returns one of {0,10,20,...,290}
       */
      function randCell(max) {
        return Math.floor(Math.random() * (max / CELL)) * CELL;
      }

      /** Place food in a random empty cell (never inside the snake). */
      function placeFood() {
        let x, y, onSnake;
        do {
          x = randCell(canvas.width);
          y = randCell(canvas.height);
          onSnake = snake.some(s => s.x === x && s.y === y);
        } while (onSnake);
        food = { x, y };
      }

      /**
       * Increase speed slightly every 5 points until a floor is reached.
       * Keeps the challenge rising without becoming unplayable.
       */
      function maybeSpeedUp() {
        if (score % 5 === 0 && tickMs > 40) tickMs -= 5;
      }

      /* ============================
         7) Pause Functionality
         ============================ */

      function togglePause() {
        if (!running) return;
        paused = !paused;
        updatePauseButton();
        drawScene(); // Redraw to show/hide pause overlay
      }

      function updatePauseButton() {
        const pauseBtn = document.getElementById('pause');
        if (!running) {
          pauseBtn.textContent = 'Pause';
          pauseBtn.disabled = true;
        } else {
          pauseBtn.textContent = paused ? 'Resume' : 'Pause';
          pauseBtn.disabled = false;
        }
      }

      /* ============================
         8) UX: Game Over and Restart
         ============================ */

      /** Draw a simple overlay to signal game over and invite a restart. */
      function gameOver() {
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 22px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 8);

        ctx.font = '16px system-ui, sans-serif';
        ctx.fillText('Press Restart or R', canvas.width / 2, canvas.height / 2 + 18);
      }

      // Click restart button to reinitialize state.
      document.getElementById('restart').addEventListener('click', () => init());

      // Click pause button to toggle pause state.
      document.getElementById('pause').addEventListener('click', togglePause);

      /* ============================
         9) Boot
         ============================ */

      // Start the first game immediately after the script loads.
      init();
    </script>
  </body>
</html>